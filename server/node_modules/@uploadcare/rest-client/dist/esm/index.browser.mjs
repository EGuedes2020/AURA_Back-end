var AddonExecutionStatus;
(function (AddonExecutionStatus) {
    AddonExecutionStatus["IN_PROGRESS"] = "in_progress";
    AddonExecutionStatus["ERROR"] = "error";
    AddonExecutionStatus["DONE"] = "done";
    AddonExecutionStatus["UNKNOWN"] = "unknown";
})(AddonExecutionStatus || (AddonExecutionStatus = {}));

var AddonName;
(function (AddonName) {
    AddonName["UC_CLAMAV_VIRUS_SCAN"] = "uc_clamav_virus_scan";
    AddonName["AWS_REKOGNITION_DETECT_LABELS"] = "aws_rekognition_detect_labels";
    AddonName["REMOVE_BG"] = "remove_bg";
})(AddonName || (AddonName = {}));

var BatchResponseStatus;
(function (BatchResponseStatus) {
    BatchResponseStatus["OK"] = "ok";
})(BatchResponseStatus || (BatchResponseStatus = {}));

var ConversionStatus;
(function (ConversionStatus) {
    ConversionStatus["PENDING"] = "pending";
    ConversionStatus["PROCESSING"] = "processing";
    ConversionStatus["FINISHED"] = "finished";
    ConversionStatus["FAILED"] = "failed";
    ConversionStatus["CANCELLED"] = "cancelled";
})(ConversionStatus || (ConversionStatus = {}));

var WebhookEvent;
(function (WebhookEvent) {
    WebhookEvent["FILE_UPLOADED"] = "file.uploaded";
})(WebhookEvent || (WebhookEvent = {}));

var ConversionType;
(function (ConversionType) {
    ConversionType["VIDEO"] = "video";
    ConversionType["DOCUMENT"] = "document";
})(ConversionType || (ConversionType = {}));

function isObject(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
}

const SEPARATOR = /\W|_/g;
function camelizeString(text) {
    return text
        .split(SEPARATOR)
        .map((word, index) => word.charAt(0)[index > 0 ? 'toUpperCase' : 'toLowerCase']() +
        word.slice(1))
        .join('');
}
function camelizeArrayItems(array, { ignoreKeys } = { ignoreKeys: [] }) {
    if (!Array.isArray(array)) {
        return array;
    }
    return array.map((item) => camelizeKeys(item, { ignoreKeys }));
}
function camelizeKeys(source, { ignoreKeys } = { ignoreKeys: [] }) {
    if (Array.isArray(source)) {
        return camelizeArrayItems(source, { ignoreKeys });
    }
    if (!isObject(source)) {
        return source;
    }
    const result = {};
    for (const key of Object.keys(source)) {
        let value = source[key];
        if (ignoreKeys.includes(key)) {
            result[key] = value;
            continue;
        }
        if (isObject(value)) {
            value = camelizeKeys(value, { ignoreKeys });
        }
        else if (Array.isArray(value)) {
            value = camelizeArrayItems(value, { ignoreKeys });
        }
        result[camelizeString(key)] = value;
    }
    return result;
}

/**
 * SetTimeout as Promise.
 *
 * @param {number} ms Timeout in milliseconds.
 */
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

function getUserAgent$1({ libraryName, libraryVersion, userAgent, publicKey = '', integration = '' }) {
    const languageName = 'JavaScript';
    if (typeof userAgent === 'string') {
        return userAgent;
    }
    if (typeof userAgent === 'function') {
        return userAgent({
            publicKey,
            libraryName,
            libraryVersion,
            languageName,
            integration
        });
    }
    const mainInfo = [libraryName, libraryVersion, publicKey]
        .filter(Boolean)
        .join('/');
    const additionInfo = [languageName, integration].filter(Boolean).join('; ');
    return `${mainInfo} (${additionInfo})`;
}

const isNode = () => {
    try {
        return Object.prototype.toString.call(global.process) === '[object process]';
    }
    catch (e) {
        return false;
    }
};

const defaultOptions = {
    factor: 2,
    time: 100
};
function retrier(fn, options = defaultOptions) {
    let attempts = 0;
    function runAttempt(fn) {
        const defaultDelayTime = Math.round(options.time * options.factor ** attempts);
        const retry = (ms) => delay(ms ?? defaultDelayTime).then(() => {
            attempts += 1;
            return runAttempt(fn);
        });
        return fn({
            attempt: attempts,
            retry
        });
    }
    return runAttempt(fn);
}

const onCancel = (signal, callback) => {
    if (signal) {
        if (signal.aborted) {
            Promise.resolve().then(callback);
        }
        else {
            signal.addEventListener('abort', () => callback(), { once: true });
        }
    }
};

class CancelError extends Error {
    isCancel = true;
    constructor(message = 'Request canceled') {
        super(message);
        Object.setPrototypeOf(this, CancelError.prototype);
    }
}

const DEFAULT_INTERVAL = 500;
const poll = ({ check, interval = DEFAULT_INTERVAL, timeout, signal }) => new Promise((resolve, reject) => {
    let tickTimeoutId;
    let timeoutId;
    onCancel(signal, () => {
        tickTimeoutId && clearTimeout(tickTimeoutId);
        reject(new CancelError('Poll cancelled'));
    });
    if (timeout) {
        timeoutId = setTimeout(() => {
            tickTimeoutId && clearTimeout(tickTimeoutId);
            reject(new CancelError('Timed out'));
        }, timeout);
    }
    const tick = () => {
        try {
            Promise.resolve(check(signal))
                .then((result) => {
                if (result) {
                    timeoutId && clearTimeout(timeoutId);
                    resolve(result);
                }
                else {
                    tickTimeoutId = setTimeout(tick, interval);
                }
            })
                .catch((error) => {
                timeoutId && clearTimeout(timeoutId);
                reject(error);
            });
        }
        catch (error) {
            timeoutId && clearTimeout(timeoutId);
            reject(error);
        }
    };
    tickTimeoutId = setTimeout(tick, 0);
});

function constructPageOptions(pageUrl, options) {
    const url = new URL(pageUrl);
    const searchParams = Object.fromEntries(url.searchParams);
    const pageOptions = {
        ...options,
        ...searchParams
    };
    return pageOptions;
}
class Paginator {
    _paginatable;
    _options;
    _settings;
    _page = null;
    constructor(paginatable, options, settings) {
        this._paginatable = paginatable;
        this._options = options;
        this._settings = settings;
    }
    updateOptions(options) {
        this._options = {
            ...this._options,
            ...options
        };
        this._page = null;
    }
    hasNextPage() {
        return !this._page || !!this._page.next;
    }
    hasPrevPage() {
        return !!this._page && !!this._page.previous;
    }
    getCurrentPage() {
        return this._page;
    }
    async next() {
        if (!this._page) {
            this._page = await this._paginatable(this._options, this._settings);
            return this._page;
        }
        if (!this._page.next) {
            return null;
        }
        const pageOptions = constructPageOptions(this._page.next, this._options);
        this._page = await this._paginatable(pageOptions, this._settings);
        return this._page;
    }
    async prev() {
        if (!this._page || !this._page.previous) {
            return null;
        }
        const pageOptions = constructPageOptions(this._page.previous, this._options);
        this._page = await this._paginatable(pageOptions, this._settings);
        return this._page;
    }
    generator() {
        return paginate(this._paginatable)(this._options, this._settings);
    }
}
function paginate(paginatable) {
    return async function* (options, settings) {
        let page = await paginatable(options, settings);
        yield page;
        while (page.next) {
            const pageOptions = constructPageOptions(page.next, options);
            page = await paginatable(pageOptions, settings);
            yield page;
        }
    };
}

const fetch = window.fetch;
const Headers = window.Headers;
const Request = window.Request;

const defaultSettings = {
    apiBaseURL: 'https://api.uploadcare.com/',
    retryThrottledRequestMaxTimes: 5,
    retryNetworkErrorMaxTimes: 3
};
const applyDefaultSettings = (userSettings) => {
    const settings = {
        ...defaultSettings,
        ...userSettings
    };
    return settings;
};

var version = '6.6.1';

const LIBRARY_NAME = 'UploadcareRestClient';
const LIBRARY_VERSION = version;
function getUserAgent(options) {
    return getUserAgent$1({
        libraryName: LIBRARY_NAME,
        libraryVersion: LIBRARY_VERSION,
        ...options
    });
}

const DEFAULT_MESSAGE = 'Unknown error';
/**
 * TODO: it's better to split errors into something like Runtime error and
 * ServerError (RestApiError)
 */
class RestClientError extends Error {
    status;
    statusText;
    request;
    response;
    constructor(message, options = {}) {
        super();
        this.name = 'RestClientError';
        this.request = options.request;
        this.response = options.response;
        this.status = options.response?.status;
        this.statusText = options.response?.statusText;
        const msg = message ?? this.statusText ?? DEFAULT_MESSAGE;
        const status = this.status || this.statusText
            ? `[${[this.status, msg === this.statusText ? '' : this.statusText]
                .filter(Boolean)
                .join(' ')}] `
            : '';
        this.message = status + msg;
        Object.setPrototypeOf(this, RestClientError.prototype);
    }
}

const THROTTLED_STATUS = 429;
const DEFAULT_RETRY_AFTER_TIMEOUT = 15000;
const DEFAULT_NETWORK_ERROR_TIMEOUT = 1000;
function getTimeoutFromThrottledRequest(response) {
    const { headers } = response;
    if (!headers || !headers.get('retry-after')) {
        return DEFAULT_RETRY_AFTER_TIMEOUT;
    }
    const seconds = parseInt(headers.get('retry-after'), 10);
    if (!Number.isFinite(seconds)) {
        return DEFAULT_RETRY_AFTER_TIMEOUT;
    }
    return seconds * 1000;
}
function retryIfFailed(fn, options) {
    return retrier(({ attempt, retry }) => fn()
        .then(async (response) => {
        if (response.status !== THROTTLED_STATUS) {
            return response;
        }
        if (attempt < options.retryThrottledRequestMaxTimes) {
            return retry(getTimeoutFromThrottledRequest(response));
        }
        const json = await response.json();
        const { detail } = json;
        throw new RestClientError(detail, { response });
    })
        .catch((error) => {
        if (attempt < options.retryNetworkErrorMaxTimes) {
            return retry((attempt + 1) * DEFAULT_NETWORK_ERROR_TIMEOUT);
        }
        throw error;
    }));
}

function normalizeQuery(input) {
    const output = {};
    for (const [key, value] of Object.entries(input)) {
        if (value === undefined || value === null) {
            continue;
        }
        if (value instanceof Date) {
            output[key] = value.toISOString();
        }
        else {
            output[key] = value.toString();
        }
    }
    return output;
}
function getRequestURL(path, query, apiBaseURL) {
    const url = new URL(apiBaseURL);
    const searchParams = new URLSearchParams(query && normalizeQuery(query));
    url.pathname = path;
    url.search = searchParams.toString();
    return url.toString();
}
async function makeApiRequest(options, userSettings) {
    const { method, path, query, body } = options;
    const settings = applyDefaultSettings(userSettings);
    if (!settings.authSchema) {
        throw new RestClientError('authSchema is required');
    }
    const url = getRequestURL(path, query, settings.apiBaseURL);
    const requestBody = body && JSON.stringify(body);
    const unsignedRequest = new Request(url, {
        method: method,
        body: requestBody,
        headers: new Headers({
            'Content-Type': 'application/json',
            'User-Agent': getUserAgent({
                publicKey: settings.authSchema.publicKey,
                integration: settings.integration,
                userAgent: settings.userAgent
            })
        })
    });
    const requestHeaders = await settings.authSchema.getHeaders(unsignedRequest);
    const signedRequest = new Request(unsignedRequest, {
        headers: requestHeaders,
        body: requestBody
    });
    const response = await retryIfFailed(() => fetch(signedRequest), {
        retryThrottledRequestMaxTimes: settings.retryThrottledRequestMaxTimes,
        retryNetworkErrorMaxTimes: settings.retryNetworkErrorMaxTimes
    });
    return {
        request: signedRequest,
        response
    };
}

const DEFAULT_API_VERSION = '0.7';
const getAcceptHeader = () => {
    return `application/vnd.uploadcare-v${DEFAULT_API_VERSION}+json`;
};

const CAMELIZE_IGNORE_KEYS = ['metadata', 'problems', 'appdata'];
const NO_CONTENT_STATUS = 204;
const isJsonContentType = (type) => type && ['application/json', getAcceptHeader()].includes(type);
async function handleApiRequest(options) {
    const { apiRequest, okCodes, camelize = true } = options;
    const { request, response } = apiRequest;
    if (response.status === NO_CONTENT_STATUS) {
        return undefined;
    }
    if (!isJsonContentType(response.headers.get('content-type'))) {
        throw new RestClientError(undefined, {
            response,
            request
        });
    }
    const json = await response.json();
    if (!okCodes.includes(response.status)) {
        throw new RestClientError(json.detail, {
            response,
            request
        });
    }
    if (!camelize) {
        return json;
    }
    return camelizeKeys(json, {
        ignoreKeys: CAMELIZE_IGNORE_KEYS
    });
}

async function addonExecutionStatus(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'GET',
        path: `/addons/${options.addonName}/execute/status/`,
        query: {
            request_id: options.requestId
        }
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [200] });
}

async function executeAddon(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'POST',
        path: `/addons/${options.addonName}/execute/`,
        body: {
            target: options.target,
            params: options.params
        }
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [200] });
}

async function fileInfo(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'GET',
        path: `/files/${options.uuid}/`,
        query: {
            include: options.include
        }
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [200] });
}

var PollStrategyJobStatus;
(function (PollStrategyJobStatus) {
    PollStrategyJobStatus[PollStrategyJobStatus["FINISHED"] = 0] = "FINISHED";
    PollStrategyJobStatus[PollStrategyJobStatus["FAILED"] = 1] = "FAILED";
})(PollStrategyJobStatus || (PollStrategyJobStatus = {}));
function createPollStrategy({ getJobStatus, job, isJobFailed, isJobFinished }) {
    return async () => {
        const statusResponse = await getJobStatus(job);
        if (isJobFinished(statusResponse)) {
            return { status: PollStrategyJobStatus.FINISHED, statusResponse };
        }
        else if (isJobFailed(statusResponse)) {
            return { status: PollStrategyJobStatus.FAILED, statusResponse };
        }
        return false;
    };
}
function createJobPoller(options) {
    const { runner, resolveJobs, getJobStatus, isJobFinished, isJobFailed, getResult, getError } = options;
    return async (options, runnerSettings) => {
        // TODO: add default timeout and inerval
        const { pollOptions, ...runnerOptions } = options;
        const response = await runner(runnerOptions, runnerSettings);
        const jobs = resolveJobs(response, runnerOptions, runnerSettings);
        if (pollOptions?.signal?.aborted) {
            throw new CancelError();
        }
        const promises = jobs.map(async (job) => {
            const pollStrategy = createPollStrategy({
                getJobStatus,
                job,
                isJobFailed,
                isJobFinished
            });
            const pollResult = await poll({
                check: pollStrategy,
                signal: pollOptions?.signal,
                interval: pollOptions?.interval,
                timeout: pollOptions?.timeout
            });
            if (pollResult.status === PollStrategyJobStatus.FINISHED) {
                const result = await getResult(job, pollResult.statusResponse);
                return result;
            }
            const error = await getError(job, pollResult.statusResponse);
            return error;
        });
        return promises;
    };
}

const addonJobPoller = async (options, settings) => {
    const { onRun, onStatus, ...pollerOptions } = options;
    const poller = createJobPoller({
        runner: executeAddon,
        resolveJobs: (response, runnerOptions, runnerSettings) => {
            onRun && onRun(response);
            return [
                {
                    target: runnerOptions.target,
                    requestId: response.requestId,
                    addonName: runnerOptions.addonName,
                    runnerSettings
                }
            ];
        },
        getJobStatus: async (job) => {
            const response = await addonExecutionStatus({
                addonName: job.addonName,
                requestId: job.requestId
            }, job.runnerSettings);
            onStatus && onStatus(response);
            return response;
        },
        isJobFinished: (statusResponse) => statusResponse.status === AddonExecutionStatus.DONE,
        isJobFailed: (statusResponse) => statusResponse.status === AddonExecutionStatus.ERROR,
        getResult: async (job) => {
            const info = await fileInfo({ uuid: job.target, include: 'appdata' }, job.runnerSettings);
            const appdata = info.appdata;
            const addonData = appdata[job.addonName];
            return {
                error: false,
                result: addonData
            };
        },
        getError: async () => ({
            error: true,
            result: null
        })
    });
    const promises = await poller(pollerOptions, settings);
    return promises[0];
};

async function conversionJobStatus(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'GET',
        path: `/convert/${options.type}/status/${options.token}/`
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [200] });
}

const storeValueToString = (store) => {
    if (typeof store === 'boolean') {
        return store ? 'true' : 'false';
    }
    if (!store || store === 'auto') {
        return undefined;
    }
    throw new RestClientError('Invalid `store` option value. Expected `true`, `false` our `"auto"`');
};

async function convert(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'POST',
        path: `/convert/${options.type}/`,
        body: {
            paths: options.paths,
            store: storeValueToString(options.store)
        }
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [200] });
}

const conversionJobPoller = (options, settings) => {
    const { onRun, onStatus, ...pollerOptions } = options;
    const poller = createJobPoller({
        runner: convert,
        resolveJobs: (response, runnerOptions, runnerSettings) => {
            onRun && onRun(response);
            return runnerOptions.paths.map((path) => {
                const problem = response.problems[path];
                if (problem) {
                    return {
                        hasProblem: true,
                        type: runnerOptions.type,
                        path,
                        problem,
                        runnerSettings
                    };
                }
                const result = response.result.find((r) => r.originalSource === path);
                return {
                    hasProblem: false,
                    type: runnerOptions.type,
                    path,
                    token: result.token,
                    result,
                    runnerSettings
                };
            });
        },
        getJobStatus: async (job) => {
            let status;
            if (job.hasProblem) {
                status = {
                    path: job.path,
                    status: ConversionStatus.FAILED,
                    error: job.problem,
                    result: null
                };
            }
            else {
                const statusResponse = await conversionJobStatus({ type: job.type, token: job.token }, job.runnerSettings);
                status = {
                    path: job.path,
                    ...statusResponse
                };
            }
            onStatus && onStatus(status);
            return status;
        },
        isJobFinished: (statusResponse) => statusResponse.status === ConversionStatus.FINISHED,
        isJobFailed: (statusResponse) => statusResponse.status === ConversionStatus.FAILED ||
            statusResponse.status === ConversionStatus.CANCELLED,
        getResult: async (job, statusResponse) => statusResponse,
        getError: async (job, statusResponse) => statusResponse
    });
    return poller(pollerOptions, settings);
};

const createSignature = (...args) => {
    return import('./createSignature.browser.b4bcb7f3.mjs').then((m) => m.createSignature(...args));
};

function hasSignatureResolver(options) {
    return !!options
        .signatureResolver;
}
function hasSecretKey(options) {
    return !!options.secretKey;
}
class UploadcareAuthSchema {
    _publicKey;
    _signatureResolver;
    _md5Loader;
    constructor(options) {
        if (hasSecretKey(options)) {
            if (!isNode()) {
                console.warn(`Seems that you're using the secret key on the client-side. We're hope you know what you're doing.`);
            }
            this._signatureResolver = (signString) => createSignature(options.secretKey, signString);
        }
        else if (hasSignatureResolver(options)) {
            this._signatureResolver = options.signatureResolver;
        }
        else {
            throw new RestClientError(`Please, provide either 'secretKey' or 'signatureResolver'`);
        }
        const { publicKey, md5Loader } = options;
        this._publicKey = publicKey;
        if (md5Loader) {
            this._md5Loader = md5Loader();
        }
        else {
            this._md5Loader = import('./md5.browser.c389165d.mjs').then((m) => m.md5);
        }
    }
    async md5(input) {
        const md5 = await this._md5Loader;
        return md5(input);
    }
    getSignString(params) {
        return [
            params.method,
            params.contentHash,
            params.contentType,
            params.date,
            params.uri
        ].join('\n');
    }
    get publicKey() {
        return this._publicKey;
    }
    async getHeaders(request) {
        const body = await request.text();
        const contentHash = await this.md5(body || '');
        const date = new Date().toUTCString();
        const url = new URL(request.url);
        const uri = url.pathname + url.search + url.hash;
        const signString = this.getSignString({
            contentType: request.headers.get('Content-Type') || '',
            method: request.method,
            contentHash,
            date,
            uri
        });
        const signature = await this._signatureResolver(signString);
        const headers = new Headers({
            ...Object.fromEntries(request.headers.entries()),
            'X-Uploadcare-Date': date,
            Accept: getAcceptHeader(),
            Authorization: `Uploadcare ${this._publicKey}:${signature}`
        });
        return headers;
    }
}

class UploadcareSimpleAuthSchema {
    _publicKey;
    _secretKey;
    constructor({ publicKey, secretKey }) {
        this._publicKey = publicKey;
        this._secretKey = secretKey;
        if (secretKey && !isNode()) {
            console.warn(`Seems that you're using the secret key on the client-side. We're hope you know that you're doing.`);
        }
    }
    get publicKey() {
        return this._publicKey;
    }
    async getHeaders(request) {
        return new Headers({
            ...Object.fromEntries(request.headers.entries()),
            Accept: getAcceptHeader(),
            Authorization: `Uploadcare.Simple ${this._publicKey}:${this._secretKey}`
        });
    }
}

async function copyFileToLocalStorage(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'POST',
        path: `/files/local_copy/`,
        body: {
            source: options.source,
            store: options.store,
            metadata: options.metadata
        }
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [201] });
}

async function copyFileToRemoteStorage(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'POST',
        path: `/files/remote_copy/`,
        body: {
            source: options.source,
            target: options.target,
            make_public: options.makePublic,
            pattern: options.pattern
        }
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [200, 201] });
}

async function deleteFile(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'DELETE',
        path: `/files/${options.uuid}/storage/`
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [200] });
}

async function deleteFiles(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'DELETE',
        path: `/files/storage/`,
        body: options.uuids
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [200] });
}

async function listOfFiles(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'GET',
        path: '/files/',
        query: {
            from: options.from,
            removed: options.removed,
            stored: options.stored,
            limit: options.limit,
            ordering: options.ordering
        }
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [200] });
}

async function storeFile(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'PUT',
        path: `/files/${options.uuid}/storage/`
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [200] });
}

async function storeFiles(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'PUT',
        path: `/files/storage/`,
        body: options.uuids
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [200] });
}

async function deleteGroup(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'DELETE',
        path: `/groups/${options.uuid}/`
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [204] });
}

async function groupInfo(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'GET',
        path: `/groups/${options.uuid}/`
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [200] });
}

async function listOfGroups(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'GET',
        path: '/groups/',
        query: {
            from: options.from,
            limit: options.limit,
            ordering: options.ordering
        }
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [200] });
}

async function deleteMetadata(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'DELETE',
        path: `/files/${options.uuid}/metadata/${options.key}/`
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [204] });
}

async function getMetadata(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'GET',
        path: `/files/${options.uuid}/metadata/`
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [200], camelize: false });
}

async function getMetadataValue(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'GET',
        path: `/files/${options.uuid}/metadata/${options.key}/`
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [200] });
}

async function updateMetadata(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'PUT',
        path: `/files/${options.uuid}/metadata/${options.key}/`,
        body: options.value
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [200, 201] });
}

async function createWebhook(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'POST',
        path: `/webhooks/`,
        body: {
            target_url: options.targetUrl,
            event: options.event,
            is_active: options.isActive,
            signing_secret: options.signingSecret
        }
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [201] });
}

async function deleteWebhook(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'DELETE',
        path: `/webhooks/unsubscribe/`,
        body: {
            target_url: options.targetUrl
        }
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [204] });
}

async function listOfWebhooks(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'GET',
        path: `/webhooks/`
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [200] });
}

async function updateWebhook(options, userSettings) {
    const apiRequest = await makeApiRequest({
        method: 'PUT',
        path: `/webhooks/${options.id}/`,
        body: {
            target_url: options.targetUrl,
            event: options.event,
            is_active: options.isActive,
            signing_secret: options.signingSecret
        }
    }, userSettings);
    return handleApiRequest({ apiRequest, okCodes: [200] });
}

export { AddonExecutionStatus, AddonName, BatchResponseStatus, ConversionStatus, ConversionType, Paginator, UploadcareAuthSchema, UploadcareSimpleAuthSchema, WebhookEvent, addonExecutionStatus, addonJobPoller, conversionJobPoller, conversionJobStatus, convert, copyFileToLocalStorage, copyFileToRemoteStorage, createSignature, createWebhook, deleteFile, deleteFiles, deleteGroup, deleteMetadata, deleteWebhook, executeAddon, fileInfo, getMetadata, getMetadataValue, getUserAgent$1 as getUserAgent, groupInfo, listOfFiles, listOfGroups, listOfWebhooks, paginate, storeFile, storeFiles, updateMetadata, updateWebhook };
