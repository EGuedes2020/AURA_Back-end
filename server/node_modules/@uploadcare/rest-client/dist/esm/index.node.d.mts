// Generated by dts-bundle-generator v6.12.0

export type CustomUserAgentOptions = {
	publicKey: string;
	libraryName: string;
	libraryVersion: string;
	languageName: string;
	integration?: string;
};
export type CustomUserAgentFn = (options: CustomUserAgentOptions) => string;
export type CustomUserAgent = string | CustomUserAgentFn;
export type GetUserAgentOptions = {
	libraryName: string;
	libraryVersion: string;
	publicKey?: string;
	integration?: string;
	userAgent?: CustomUserAgent | null;
};
export declare function getUserAgent({ libraryName, libraryVersion, userAgent, publicKey, integration }: GetUserAgentOptions): string;
export type GeoLocation = {
	latitude: number;
	longitude: number;
};
export type ImageInfo = {
	height: number;
	width: number;
	geoLocation: GeoLocation | null;
	datetimeOriginal: string;
	format: string;
	colorMode: string;
	dpi: {
		"0": number;
		"1": number;
	} | null;
	orientation: number | null;
	sequence: boolean | null;
};
export type AudioInfo = {
	bitrate: number | null;
	codec: string | null;
	sampleRate: number | null;
	channels: string | null;
};
export type VideoInfo = {
	duration: number;
	format: string;
	bitrate: number;
	audio: AudioInfo | null;
	video: {
		height: number;
		width: number;
		frameRate: number;
		bitrate: number;
		codec: string;
	};
};
export type MimeInfo = {
	mime: string;
	type: string;
	subtype: string;
};
export type ContentInfo = {
	mime?: MimeInfo;
	image?: ImageInfo;
	video?: VideoInfo;
};
export type Metadata = Record<string, string>;
export type StoreValue = "auto" | boolean;
export type AuthSchema = {
	publicKey: string;
	getHeaders(request: Request): Promise<Headers>;
};
export type UserSettings = {
	authSchema: AuthSchema;
	apiBaseURL?: string;
	retryThrottledRequestMaxTimes?: number;
	retryNetworkErrorMaxTimes?: number;
	integration?: string;
	userAgent?: CustomUserAgent;
};
export type ApiRequestSettings = UserSettings;
export declare enum AddonExecutionStatus {
	IN_PROGRESS = "in_progress",
	ERROR = "error",
	DONE = "done",
	UNKNOWN = "unknown"
}
export declare enum AddonName {
	UC_CLAMAV_VIRUS_SCAN = "uc_clamav_virus_scan",
	AWS_REKOGNITION_DETECT_LABELS = "aws_rekognition_detect_labels",
	REMOVE_BG = "remove_bg"
}
export type AddonUcClamavVirusScanParams = {
	purge_infected: boolean;
};
export type AddonAwsRekognitionDetectLabelsParams = undefined;
export type AddonRemoveBgParams = {
	crop?: boolean;
	crop_margin?: string;
	scale?: string;
	add_shadow?: boolean;
	type_level?: "none" | "1" | "2" | "latest";
	type?: "auto" | "person" | "product" | "car";
	semitransparency?: boolean;
	channels?: "rgba" | "alpha";
	roi?: string;
	position?: string;
};
export type AddonParams = {
	[AddonName.UC_CLAMAV_VIRUS_SCAN]: AddonUcClamavVirusScanParams;
	[AddonName.AWS_REKOGNITION_DETECT_LABELS]: AddonAwsRekognitionDetectLabelsParams;
	[AddonName.REMOVE_BG]: AddonRemoveBgParams;
};
export type ClamavVirusScan = {
	data: {
		infected: boolean;
		infected_with: string;
	};
	version: string;
	datetime_created: string;
	datetime_updated: string;
};
export type AwsRekognitionDetectLabelParent = {
	Name: string;
};
export type AwsRekognitionDetectLabelInstance = {
	Confidence: number;
	BoundingBox: {
		Height: number;
		Left: number;
		Top: number;
		Width: number;
	};
};
export type AwsRekognitionDetectLabel = {
	Confidence: number;
	Name: string;
	Parents: AwsRekognitionDetectLabelParent[];
	Instances: AwsRekognitionDetectLabelInstance[];
};
export type AwsRekognitionDetectLabels = {
	data: {
		LabelModelVersion: string;
		Labels: AwsRekognitionDetectLabel[];
	};
	version: string;
	datetime_created: string;
	datetime_updated: string;
};
export type RemoveBg = {
	data: {
		foreground_type: string;
	};
	version: string;
	datetime_created: string;
	datetime_updated: string;
};
export type AppData = {
	[AddonName.UC_CLAMAV_VIRUS_SCAN]?: ClamavVirusScan;
	[AddonName.AWS_REKOGNITION_DETECT_LABELS]?: AwsRekognitionDetectLabels;
	[AddonName.REMOVE_BG]?: RemoveBg;
};
export type Problems = Record<string, string>;
export declare enum BatchResponseStatus {
	OK = "ok"
}
export type BatchResponse<T> = {
	status: BatchResponseStatus;
	problems: Problems;
	result: T[];
};
export declare enum ConversionStatus {
	PENDING = "pending",
	PROCESSING = "processing",
	FINISHED = "finished",
	FAILED = "failed",
	CANCELLED = "cancelled"
}
export type FileInfoVariations = string[];
export type FileInfo = {
	datetimeRemoved: string | null;
	datetimeStored: string | null;
	datetimeUploaded: string;
	isImage: boolean;
	isReady: boolean;
	mimeType: string;
	originalFileUrl: string | null;
	originalFilename: string;
	size: number;
	url: string;
	uuid: string;
	variations: FileInfoVariations | null;
	contentInfo: ContentInfo | null;
	metadata: Metadata | null;
	appdata: AppData | null;
};
export type GroupInfo = {
	files: FileInfo[];
	id: string;
	datetimeCreated: string;
	filesCount: number;
	cdnUrl: string;
	url: string;
};
export type GroupInfoShort = Omit<GroupInfo, "files">;
export type PaginatedList<PageItem, PageExtra = Record<string, never>> = {
	next: string | null;
	previous: string | null;
	total: number;
	perPage: number;
	results: PageItem[];
} & PageExtra;
export type ServerErrorResponse = {
	detail: string;
};
export declare enum WebhookEvent {
	FILE_UPLOADED = "file.uploaded"
}
export type Webhook = {
	id: number;
	project: number;
	created: string;
	updated: string;
	event: WebhookEvent;
	targetUrl: string;
	isActive: boolean;
	signingSecret: string;
	version: string;
};
export type Paginatable<Options, Settings, PageItem, PageExtra> = (options: Options, settings: Settings) => Promise<PaginatedList<PageItem, PageExtra>>;
export type Md5Function = (input: string) => string;
export declare enum ConversionType {
	VIDEO = "video",
	DOCUMENT = "document"
}
export type ValueOf<T> = T[keyof T];
export type ConversionOptions<T extends ValueOf<typeof ConversionType>> = {
	type: T;
	paths: string[];
	store?: StoreValue;
};
export interface ConversionResultBase {
	originalSource: string;
	uuid: string;
	token: number;
}
export type ConversionResultDocument = ConversionResultBase;
export interface ConversionResultVideo extends ConversionResultBase {
	thumbnailsGroupUuid: string;
}
export type ConversionResult = {
	[ConversionType.VIDEO]: ConversionResultVideo;
	[ConversionType.DOCUMENT]: ConversionResultDocument;
};
export type ConversionResponse<T extends ValueOf<ConversionResult>> = {
	problems: Problems;
	result: T[];
};
export type ConversionStatusOptions<T extends ValueOf<typeof ConversionType>> = {
	type: T;
	token: number;
};
export interface ConversionStatusResultBase {
	uuid: string;
}
export type ConversionStatusResultDocument = ConversionStatusResultBase;
export interface ConversionStatusResultVideo extends ConversionStatusResultBase {
	thumbnailsGroupUuid: string;
}
export type ConversionStatusResult = {
	[ConversionType.VIDEO]: ConversionStatusResultVideo;
	[ConversionType.DOCUMENT]: ConversionStatusResultDocument;
};
export type ConversionStatusResponse<T extends ValueOf<ConversionStatusResult>> = {
	status: ConversionStatus;
	error: string | null;
	result: T | null;
};
export type ApiMethod<Options extends Record<string, unknown>, Settings extends Record<string, unknown>, Response> = (options: Options, settings: Settings) => Promise<Response>;
export declare class Paginator<Options, Settings, PageItem, PageExtra> {
	private _paginatable;
	private _options;
	private _settings;
	private _page;
	constructor(paginatable: Paginatable<Options, Settings, PageItem, PageExtra>, options: Options, settings: Settings);
	updateOptions(options: Options): void;
	hasNextPage(): boolean;
	hasPrevPage(): boolean;
	getCurrentPage(): PaginatedList<PageItem, PageExtra> | null;
	next(): Promise<PaginatedList<PageItem, PageExtra> | null>;
	prev(): Promise<PaginatedList<PageItem, PageExtra> | null>;
	generator(): AsyncGenerator<PaginatedList<PageItem, PageExtra>, void, unknown>;
}
export declare function paginate<Options, Settings, PageItem, PageExtra>(paginatable: Paginatable<Options, Settings, PageItem, PageExtra>): (options: Options, settings: Settings) => AsyncGenerator<PaginatedList<PageItem, PageExtra>, void, unknown>;
export type AddonExecutionStatusOptions<T extends ValueOf<typeof AddonName>> = {
	addonName: T;
	requestId: string;
};
export type AddonExecutionStatusResponse = {
	status: AddonExecutionStatus;
};
export declare function addonExecutionStatus<T extends ValueOf<typeof AddonName>>(options: AddonExecutionStatusOptions<T>, userSettings: ApiRequestSettings): Promise<AddonExecutionStatusResponse>;
export type ExecuteAddonOptions<T extends ValueOf<typeof AddonName>> = {
	addonName: T;
	target: string;
	params?: AddonParams[T];
};
export type ExecuteAddonResponse = {
	requestId: string;
};
export declare function executeAddon<T extends ValueOf<typeof AddonName>>(options: ExecuteAddonOptions<T>, userSettings: ApiRequestSettings): Promise<ExecuteAddonResponse>;
export type CreateJobPollerPollOptions = {
	pollOptions?: {
		signal?: AbortSignal;
		interval?: number;
		timeout?: number;
	};
};
export type AddonJobPollerOptions = {
	onRun?: (response: ExecuteAddonResponse) => void;
	onStatus?: (response: AddonExecutionStatusResponse) => void;
};
export declare const addonJobPoller: <T extends ValueOf<typeof AddonName>>(options: ExecuteAddonOptions<T> & CreateJobPollerPollOptions & AddonJobPollerOptions, settings: ApiRequestSettings) => Promise<{
	error: true;
	result: null;
} | {
	error: false;
	result: NonNullable<AppData[T]>;
}>;
export type ConversionJobPollerOptions<T extends ValueOf<typeof ConversionType>> = {
	onRun?: (response: ConversionResponse<ConversionResult[T]>) => void;
	onStatus?: (response: ConversionStatusResponse<ConversionStatusResult[T]>) => void;
};
export declare const conversionJobPoller: <T extends ValueOf<typeof ConversionType>>(options: ConversionOptions<T> & CreateJobPollerPollOptions & ConversionJobPollerOptions<T>, settings: ApiRequestSettings) => Promise<Promise<{
	path: string;
} & ConversionStatusResponse<ConversionStatusResult[T]>>[]>;
export declare const createSignature: (secretKey: string, signString: string) => Promise<string>;
export type UploadcareAuthSchemaSignatureResolver = (signString: string) => Promise<string>;
export type UploadcareAuthSchemaOptionsWithSignatureResolver = {
	publicKey: string;
	signatureResolver: UploadcareAuthSchemaSignatureResolver;
	md5Loader?: () => Promise<Md5Function>;
};
export type UploadcareAuthSchemaOptionsWithSecretKey = {
	publicKey: string;
	secretKey: string;
	md5Loader?: () => Promise<Md5Function>;
};
export declare class UploadcareAuthSchema implements AuthSchema {
	private _publicKey;
	private _signatureResolver;
	private _md5Loader;
	constructor(options: UploadcareAuthSchemaOptionsWithSignatureResolver | UploadcareAuthSchemaOptionsWithSecretKey);
	private md5;
	private getSignString;
	get publicKey(): string;
	getHeaders(request: Request): Promise<Headers>;
}
export type UploadcareSimpleAuthSchemaOptions = {
	publicKey: string;
	secretKey: string;
};
export declare class UploadcareSimpleAuthSchema implements AuthSchema {
	private _publicKey;
	private _secretKey;
	constructor({ publicKey, secretKey }: UploadcareSimpleAuthSchemaOptions);
	get publicKey(): string;
	getHeaders(request: Request): Promise<Headers>;
}
export type CopyFileToLocalStorageOptions = {
	source: string;
	store?: boolean;
	metadata?: Metadata;
};
/**
 * There is a bug in the API. FileInfo will be incomplete. It's better to
 * refetch fileInfo after request in the high-level wrappers.
 */
export type CopyFileToLocalStorageResponse = {
	type: "file";
	result: FileInfo;
};
export declare function copyFileToLocalStorage(options: CopyFileToLocalStorageOptions, userSettings: ApiRequestSettings): Promise<CopyFileToLocalStorageResponse>;
export type CopyFileToRemoteStorageOptions = {
	source: string;
	target: string;
	makePublic?: boolean;
	pattern?: string;
};
export type CopyFileToRemoteStorageResponse = {
	type: "url";
	result: string;
};
export declare function copyFileToRemoteStorage(options: CopyFileToRemoteStorageOptions, userSettings: ApiRequestSettings): Promise<CopyFileToRemoteStorageResponse>;
export type DeleteFileOptions = {
	uuid: string;
};
export type DeleteFileResponse = FileInfo;
export declare function deleteFile(options: DeleteFileOptions, userSettings: ApiRequestSettings): Promise<DeleteFileResponse>;
export type DeleteFilesOptions = {
	uuids: string[];
};
export type DeleteFilesResponse = BatchResponse<FileInfo>;
export declare function deleteFiles(options: DeleteFilesOptions, userSettings: ApiRequestSettings): Promise<DeleteFilesResponse>;
export type FileInfoOptions = {
	uuid: string;
	include?: string;
};
export type FileInfoResponse = FileInfo;
export declare function fileInfo(options: FileInfoOptions, userSettings: ApiRequestSettings): Promise<FileInfoResponse>;
export type ListOfFilesOrdering = "datetime_uploaded" | "-datetime_uploaded";
export type ListOfFilesOptions = {
	from?: Date;
	removed?: boolean;
	stored?: boolean;
	limit?: number;
	ordering?: ListOfFilesOrdering;
};
export type ListOfFilesTotals = {
	removed: number;
	stored: number;
	unstored: number;
};
export type ListOfFilesResponse = PaginatedList<FileInfo, {
	totals: ListOfFilesTotals;
}>;
export declare function listOfFiles(options: ListOfFilesOptions, userSettings: ApiRequestSettings): Promise<ListOfFilesResponse>;
export type StoreFileOptions = {
	uuid: string;
};
export type StoreFileResponse = FileInfo;
export declare function storeFile(options: StoreFileOptions, userSettings: ApiRequestSettings): Promise<StoreFileResponse>;
export type StoreFilesOptions = {
	uuids: string[];
};
export type StoreFilesResponse = BatchResponse<FileInfo>;
export declare function storeFiles(options: StoreFilesOptions, userSettings: ApiRequestSettings): Promise<StoreFilesResponse>;
export type DeleteGroupOptions = {
	uuid: string;
};
export type DeleteGroupResponse = void;
export declare function deleteGroup(options: DeleteGroupOptions, userSettings: ApiRequestSettings): Promise<DeleteGroupResponse>;
export type GroupInfoOptions = {
	uuid: string;
};
export type GroupInfoResponse = GroupInfo;
export declare function groupInfo(options: GroupInfoOptions, userSettings: ApiRequestSettings): Promise<GroupInfoResponse>;
export type ListOfGroupsOrdering = "datetime_created" | "-datetime_created";
export type ListOfGroupsOptions = {
	from?: Date;
	limit?: number;
	ordering?: ListOfGroupsOrdering;
};
export type ListOfGroupsResponse = PaginatedList<GroupInfoShort>;
export declare function listOfGroups(options: ListOfGroupsOptions, userSettings: ApiRequestSettings): Promise<ListOfGroupsResponse>;
export type DeleteMetadataOptions = {
	uuid: string;
	key: string;
};
export type DeleteMetadataResponse = void;
export declare function deleteMetadata(options: DeleteMetadataOptions, userSettings: ApiRequestSettings): Promise<DeleteMetadataResponse>;
export type GetMetadataOptions = {
	uuid: string;
};
export type GetMetadataResponse = Metadata;
export declare function getMetadata(options: GetMetadataOptions, userSettings: ApiRequestSettings): Promise<GetMetadataResponse>;
export type GetMetadataValueOptions = {
	uuid: string;
	key: string;
};
export type GetMetadataValueResponse = Metadata;
export declare function getMetadataValue(options: GetMetadataValueOptions, userSettings: ApiRequestSettings): Promise<GetMetadataValueResponse>;
export type UpdateMetadataOptions = {
	uuid: string;
	key: string;
	value: string;
};
export type UpdateMetadataResponse = string;
export declare function updateMetadata(options: UpdateMetadataOptions, userSettings: ApiRequestSettings): Promise<UpdateMetadataResponse>;
export type CreateWebhookOptions = Pick<Webhook, "targetUrl" | "event"> & Partial<Pick<Webhook, "isActive" | "signingSecret" | "version">>;
export type CreateWebhookResponse = Webhook;
export declare function createWebhook(options: CreateWebhookOptions, userSettings: ApiRequestSettings): Promise<CreateWebhookResponse>;
export type DeleteWebhookOptions = Pick<Webhook, "targetUrl">;
export type DeleteWebhookResponse = void;
export declare function deleteWebhook(options: DeleteWebhookOptions, userSettings: ApiRequestSettings): Promise<DeleteWebhookResponse>;
export type ListOfWebhooksOptions = Record<string, never>;
export type ListOfWebhooksResponse = Webhook[];
export declare function listOfWebhooks(options: ListOfWebhooksOptions, userSettings: ApiRequestSettings): Promise<ListOfWebhooksResponse>;
export type UpdateWebhookOptions = Pick<Webhook, "id"> & Partial<Pick<Webhook, "targetUrl" | "event" | "isActive" | "signingSecret">>;
export type UpdateWebhookResponse = Webhook;
export declare function updateWebhook(options: UpdateWebhookOptions, userSettings: ApiRequestSettings): Promise<UpdateWebhookResponse>;
export declare function convert<T extends ValueOf<typeof ConversionType>>(options: ConversionOptions<T>, userSettings: ApiRequestSettings): Promise<ConversionResponse<ConversionResult[T]>>;
export declare function conversionJobStatus<T extends ValueOf<typeof ConversionType>>(options: ConversionStatusOptions<T>, userSettings: ApiRequestSettings): Promise<ConversionStatusResponse<ConversionStatusResult[T]>>;

export {};
