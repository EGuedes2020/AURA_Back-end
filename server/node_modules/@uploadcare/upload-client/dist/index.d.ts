// Generated by dts-bundle-generator v6.12.0

import NodeFormData from 'form-data';

export type CustomUserAgentOptions = {
	publicKey: string;
	libraryName: string;
	libraryVersion: string;
	languageName: string;
	integration?: string;
};
export type CustomUserAgentFn = (options: CustomUserAgentOptions) => string;
export type CustomUserAgent = string | CustomUserAgentFn;
export type GetUserAgentOptions = {
	libraryName: string;
	libraryVersion: string;
	publicKey?: string;
	integration?: string;
	userAgent?: CustomUserAgent | null;
};
export declare function getUserAgent({ libraryName, libraryVersion, userAgent, publicKey, integration }: GetUserAgentOptions): string;
export declare class UploadcareNetworkError extends Error {
	originalProgressEvent: ProgressEvent;
	constructor(progressEvent: ProgressEvent);
}
export type GeoLocation = {
	latitude: number;
	longitude: number;
};
export type ImageInfo = {
	height: number;
	width: number;
	geoLocation: GeoLocation | null;
	datetimeOriginal: string;
	format: string;
	colorMode: string;
	dpi: {
		"0": number;
		"1": number;
	} | null;
	orientation: number | null;
	sequence: boolean | null;
};
export type AudioInfo = {
	bitrate: number | null;
	codec: string | null;
	sampleRate: number | null;
	channels: string | null;
};
export type VideoInfo = {
	duration: number;
	format: string;
	bitrate: number;
	audio: AudioInfo | null;
	video: {
		height: number;
		width: number;
		frameRate: number;
		bitrate: number;
		codec: string;
	};
};
export type MimeInfo = {
	mime: string;
	type: string;
	subtype: string;
};
export type ContentInfo = {
	mime?: MimeInfo;
	image?: ImageInfo;
	video?: VideoInfo;
};
export type Metadata = Record<string, string>;
export type StoreValue = "auto" | boolean;
export interface DefaultSettings {
	baseCDN: string;
	baseURL: string;
	maxContentLength: number;
	retryThrottledRequestMaxTimes: number;
	retryNetworkErrorMaxTimes: number;
	multipartMinFileSize: number;
	multipartChunkSize: number;
	multipartMinLastPartSize: number;
	maxConcurrentRequests: number;
	pollingTimeoutMilliseconds: number;
	pusherKey: string;
}
export interface Settings extends Partial<DefaultSettings> {
	publicKey: string;
	fileName?: string;
	contentType?: string;
	store?: StoreValue;
	secureSignature?: string;
	secureExpire?: string;
	integration?: string;
	userAgent?: CustomUserAgent;
	checkForUrlDuplicates?: boolean;
	saveUrlForRecurrentUploads?: boolean;
	source?: string;
	jsonpCallback?: string;
}
export type BrowserFile = Blob | File;
export type NodeFile = Buffer;
export type ReactNativeAsset = {
	type: string;
	uri: string;
	name?: string;
};
export type SupportedFileInput = BrowserFile | NodeFile | ReactNativeAsset;
export type Sliceable = BrowserFile | NodeFile;
export type FileInfo = {
	size: number;
	done: number;
	total: number;
	uuid: Uuid;
	fileId: Uuid;
	originalFilename: string;
	filename: string;
	mimeType: string;
	isImage: boolean;
	isStored: boolean;
	isReady: string;
	imageInfo: ImageInfo | null;
	videoInfo: VideoInfo | null;
	contentInfo: ContentInfo | null;
	s3Bucket?: string;
	metadata?: Metadata;
};
export type GroupInfo = {
	datetimeCreated: string;
	datetimeStored: string | null;
	filesCount: string;
	cdnUrl: string;
	files: FileInfo[];
	url: string;
	id: GroupId;
};
export type Token = string;
export type Uuid = string;
export type GroupId = string;
export type Url = string;
export type ComputableProgressInfo = {
	isComputable: true;
	value: number;
};
export type UnknownProgressInfo = {
	isComputable: false;
};
export type ProgressCallback<T = ComputableProgressInfo | UnknownProgressInfo> = (arg: T) => void;
export type BaseResponse = {
	file: Uuid;
};
export type BaseOptions = {
	publicKey: string;
	fileName?: string;
	baseURL?: string;
	secureSignature?: string;
	secureExpire?: string;
	store?: StoreValue;
	contentType?: string;
	signal?: AbortSignal;
	onProgress?: ProgressCallback;
	source?: string;
	integration?: string;
	userAgent?: CustomUserAgent;
	retryThrottledRequestMaxTimes?: number;
	retryNetworkErrorMaxTimes?: number;
	metadata?: Metadata;
};
/**
 * Performs file uploading request to Uploadcare Upload API. Can be canceled and
 * has progress.
 */
export function base(file: SupportedFileInput, { publicKey, fileName, contentType, baseURL, secureSignature, secureExpire, store, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, metadata }: BaseOptions): Promise<BaseResponse>;
export declare enum TypeEnum {
	Token = "token",
	FileInfo = "file_info"
}
export type TokenResponse = {
	type: TypeEnum.Token;
	token: string;
};
export type FileInfoResponse = {
	type: TypeEnum.FileInfo;
} & FileInfo;
export type FromUrlSuccessResponse = FileInfoResponse | TokenResponse;
export type FromUrlResponse = FromUrlSuccessResponse;
export type FromUrlOptions = {
	publicKey: string;
	baseURL?: string;
	store?: StoreValue;
	fileName?: string;
	checkForUrlDuplicates?: boolean;
	saveUrlForRecurrentUploads?: boolean;
	secureSignature?: string;
	secureExpire?: string;
	signal?: AbortSignal;
	source?: string;
	integration?: string;
	userAgent?: CustomUserAgent;
	retryThrottledRequestMaxTimes?: number;
	retryNetworkErrorMaxTimes?: number;
	metadata?: Metadata;
};
/** Uploading files from URL. */
export function fromUrl(sourceUrl: Url, { publicKey, baseURL, store, fileName, checkForUrlDuplicates, saveUrlForRecurrentUploads, secureSignature, secureExpire, source, signal, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, metadata }: FromUrlOptions): Promise<FromUrlSuccessResponse>;
export declare enum Status {
	Unknown = "unknown",
	Waiting = "waiting",
	Progress = "progress",
	Error = "error",
	Success = "success"
}
export type StatusUnknownResponse = {
	status: Status.Unknown;
};
export type StatusWaitingResponse = {
	status: Status.Waiting;
};
export type StatusProgressResponse = {
	status: Status.Progress;
	size: number;
	done: number;
	total: number | "unknown";
};
export type StatusErrorResponse = {
	status: Status.Error;
	error: string;
	errorCode: string;
};
export type StatusSuccessResponse = {
	status: Status.Success;
} & FileInfo;
export type FromUrlStatusResponse = StatusUnknownResponse | StatusWaitingResponse | StatusProgressResponse | StatusErrorResponse | StatusSuccessResponse;
export type FromUrlStatusOptions = {
	publicKey?: string;
	baseURL?: string;
	signal?: AbortSignal;
	integration?: string;
	userAgent?: CustomUserAgent;
	retryThrottledRequestMaxTimes?: number;
	retryNetworkErrorMaxTimes?: number;
};
/** Checking upload status and working with file tokens. */
export function fromUrlStatus(token: Token, { publicKey, baseURL, signal, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes }?: FromUrlStatusOptions): Promise<FromUrlStatusResponse>;
export type GroupOptions = {
	publicKey: string;
	baseURL?: string;
	jsonpCallback?: string;
	secureSignature?: string;
	secureExpire?: string;
	signal?: AbortSignal;
	source?: string;
	integration?: string;
	userAgent?: CustomUserAgent;
	retryThrottledRequestMaxTimes?: number;
	retryNetworkErrorMaxTimes?: number;
};
/** Create files group. */
export function group(uuids: Uuid[], { publicKey, baseURL, jsonpCallback, secureSignature, secureExpire, signal, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes }: GroupOptions): Promise<GroupInfo>;
export type GroupInfoOptions = {
	publicKey: string;
	baseURL?: string;
	signal?: AbortSignal;
	source?: string;
	integration?: string;
	userAgent?: CustomUserAgent;
	retryThrottledRequestMaxTimes?: number;
	retryNetworkErrorMaxTimes?: number;
};
/** Get info about group. */
export function groupInfo(id: GroupId, { publicKey, baseURL, signal, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes }: GroupInfoOptions): Promise<GroupInfo>;
export type InfoOptions = {
	publicKey: string;
	baseURL?: string;
	signal?: AbortSignal;
	source?: string;
	integration?: string;
	userAgent?: CustomUserAgent;
	retryThrottledRequestMaxTimes?: number;
	retryNetworkErrorMaxTimes?: number;
};
/** Returns a JSON dictionary holding file info. */
export function info(uuid: Uuid, { publicKey, baseURL, signal, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes }: InfoOptions): Promise<FileInfo>;
export type MultipartStartOptions = {
	publicKey: string;
	contentType?: string;
	fileName?: string;
	baseURL?: string;
	secureSignature?: string;
	secureExpire?: string;
	store?: StoreValue;
	multipartChunkSize?: number;
	signal?: AbortSignal;
	source?: string;
	integration?: string;
	userAgent?: CustomUserAgent;
	retryThrottledRequestMaxTimes?: number;
	retryNetworkErrorMaxTimes?: number;
	metadata?: Metadata;
};
export type MultipartPart = string;
export type MultipartStartResponse = {
	parts: MultipartPart[];
	uuid: Uuid;
};
/** Start multipart uploading. */
export function multipartStart(size: number, { publicKey, contentType, fileName, multipartChunkSize, baseURL, secureSignature, secureExpire, store, signal, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, metadata }: MultipartStartOptions): Promise<MultipartStartResponse>;
export type MultipartUploadOptions = {
	publicKey?: string;
	contentType?: string;
	signal?: AbortSignal;
	onProgress?: ProgressCallback<ComputableProgressInfo>;
	integration?: string;
	retryThrottledRequestMaxTimes?: number;
	retryNetworkErrorMaxTimes?: number;
};
export type MultipartUploadResponse = {
	code?: number;
};
/** Complete multipart uploading. */
export function multipartUpload(part: SupportedFileInput, url: MultipartPart, { contentType, signal, onProgress, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes }: MultipartUploadOptions): Promise<MultipartUploadResponse>;
export type MultipartCompleteOptions = {
	publicKey: string;
	baseURL?: string;
	signal?: AbortSignal;
	source?: string;
	integration?: string;
	userAgent?: CustomUserAgent;
	retryThrottledRequestMaxTimes?: number;
	retryNetworkErrorMaxTimes?: number;
};
/** Complete multipart uploading. */
export function multipartComplete(uuid: Uuid, { publicKey, baseURL, source, signal, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes }: MultipartCompleteOptions): Promise<FileInfo>;
export declare class UploadcareFile {
	readonly uuid: Uuid;
	readonly name: null | string;
	readonly size: null | number;
	readonly isStored: null | boolean;
	readonly isImage: null | boolean;
	readonly mimeType: null | string;
	readonly cdnUrl: null | string;
	readonly s3Url: null | string;
	readonly originalFilename: null | string;
	readonly imageInfo: null | ImageInfo;
	readonly videoInfo: null | VideoInfo;
	readonly contentInfo: null | ContentInfo;
	readonly metadata: null | Metadata;
	readonly s3Bucket: null | string;
	constructor(fileInfo: FileInfo, { baseCDN, fileName }?: {
		baseCDN?: string;
		fileName?: string;
	});
}
export type FileFromOptions = {
	publicKey: string;
	fileName?: string;
	baseURL?: string;
	secureSignature?: string;
	secureExpire?: string;
	store?: StoreValue;
	signal?: AbortSignal;
	onProgress?: ProgressCallback;
	source?: string;
	integration?: string;
	userAgent?: CustomUserAgent;
	retryThrottledRequestMaxTimes?: number;
	retryNetworkErrorMaxTimes?: number;
	contentType?: string;
	multipartMinFileSize?: number;
	multipartChunkSize?: number;
	maxConcurrentRequests?: number;
	baseCDN?: string;
	checkForUrlDuplicates?: boolean;
	saveUrlForRecurrentUploads?: boolean;
	pusherKey?: string;
	metadata?: Metadata;
};
/** Uploads file from provided data. */
export declare function uploadFile(data: SupportedFileInput | Url | Uuid, { publicKey, fileName, baseURL, secureSignature, secureExpire, store, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, contentType, multipartMinFileSize, multipartChunkSize, maxConcurrentRequests, baseCDN, checkForUrlDuplicates, saveUrlForRecurrentUploads, pusherKey, metadata }: FileFromOptions): Promise<UploadcareFile>;
export type DirectOptions = {
	publicKey: string;
	fileName?: string;
	baseURL?: string;
	secureSignature?: string;
	secureExpire?: string;
	store?: StoreValue;
	contentType?: string;
	signal?: AbortSignal;
	onProgress?: ProgressCallback;
	source?: string;
	integration?: string;
	userAgent?: CustomUserAgent;
	retryThrottledRequestMaxTimes?: number;
	retryNetworkErrorMaxTimes?: number;
	baseCDN?: string;
	metadata?: Metadata;
};
export declare const uploadDirect: (file: SupportedFileInput, { publicKey, fileName, baseURL, secureSignature, secureExpire, store, contentType, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, baseCDN, metadata }: DirectOptions) => Promise<UploadcareFile>;
export type FromUploadedOptions = {
	publicKey: string;
	fileName?: string;
	baseURL?: string;
	signal?: AbortSignal;
	onProgress?: ProgressCallback;
	source?: string;
	integration?: string;
	userAgent?: CustomUserAgent;
	retryThrottledRequestMaxTimes?: number;
	retryNetworkErrorMaxTimes?: number;
	baseCDN?: string;
};
export declare const uploadFromUploaded: (uuid: Uuid, { publicKey, fileName, baseURL, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, baseCDN }: FromUploadedOptions) => Promise<UploadcareFile>;
export type UploadFromUrlOptions = {
	baseCDN?: string;
	onProgress?: ProgressCallback;
	pusherKey?: string;
} & FromUrlOptions;
export declare const uploadFromUrl: (sourceUrl: string, { publicKey, fileName, baseURL, baseCDN, checkForUrlDuplicates, saveUrlForRecurrentUploads, secureSignature, secureExpire, store, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, pusherKey, metadata }: UploadFromUrlOptions) => Promise<UploadcareFile>;
export type MultipartOptions = {
	publicKey: string;
	contentType?: string;
	multipartChunkSize?: number;
	fileName?: string;
	fileSize?: number;
	baseURL?: string;
	secureSignature?: string;
	secureExpire?: string;
	store?: StoreValue;
	signal?: AbortSignal;
	onProgress?: ProgressCallback<ComputableProgressInfo>;
	source?: string;
	integration?: string;
	userAgent?: CustomUserAgent;
	retryThrottledRequestMaxTimes?: number;
	retryNetworkErrorMaxTimes?: number;
	maxConcurrentRequests?: number;
	baseCDN?: string;
	metadata?: Metadata;
};
export declare const uploadMultipart: (file: SupportedFileInput, { publicKey, fileName, fileSize, baseURL, secureSignature, secureExpire, store, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, contentType, multipartChunkSize, maxConcurrentRequests, baseCDN, metadata }: MultipartOptions) => Promise<UploadcareFile>;
export declare class UploadcareGroup {
	readonly uuid: GroupId;
	readonly filesCount: string;
	readonly totalSize: number;
	readonly isStored: boolean;
	readonly isImage: boolean;
	readonly cdnUrl: string;
	readonly files: UploadcareFile[];
	readonly createdAt: string;
	readonly storedAt: string | null;
	constructor(groupInfo: GroupInfo, files: UploadcareFile[]);
}
export type GroupFromOptions = {
	jsonpCallback?: string;
};
export declare function uploadFileGroup(data: SupportedFileInput[] | Url[] | Uuid[], { publicKey, fileName, baseURL, secureSignature, secureExpire, store, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, contentType, multipartChunkSize, baseCDN, checkForUrlDuplicates, saveUrlForRecurrentUploads, jsonpCallback }: FileFromOptions & GroupFromOptions): Promise<UploadcareGroup>;
export declare class UploadClient {
	private settings;
	constructor(settings: Settings);
	updateSettings(newSettings: Settings): void;
	getSettings(): Settings;
	base(file: SupportedFileInput, options?: Partial<BaseOptions>): Promise<BaseResponse>;
	info(uuid: Uuid, options?: Partial<InfoOptions>): Promise<FileInfo>;
	fromUrl(sourceUrl: Url, options?: Partial<FromUrlOptions>): Promise<FromUrlResponse>;
	fromUrlStatus(token: Token, options?: Partial<FromUrlStatusOptions>): Promise<FromUrlStatusResponse>;
	group(uuids: Uuid[], options?: Partial<GroupOptions>): Promise<GroupInfo>;
	groupInfo(id: GroupId, options?: Partial<GroupInfoOptions>): Promise<GroupInfo>;
	multipartStart(size: number, options?: Partial<MultipartStartOptions>): Promise<MultipartStartResponse>;
	multipartUpload(part: Sliceable, url: MultipartPart, options?: Partial<MultipartUploadOptions>): Promise<MultipartUploadResponse>;
	multipartComplete(uuid: Uuid, options?: Partial<MultipartCompleteOptions>): Promise<FileInfo>;
	uploadFile(data: SupportedFileInput | Url | Uuid, options?: Partial<FileFromOptions>): Promise<UploadcareFile>;
	uploadFileGroup(data: SupportedFileInput[] | Url[] | Uuid[], options?: Partial<FileFromOptions & GroupFromOptions>): Promise<UploadcareGroup>;
}
export type Task<T = unknown> = () => Promise<T>;
export declare class Queue {
	#private;
	constructor(concurrency: number);
	add<T>(task: Task<T>): Promise<T>;
	get pending(): number;
	get running(): number;
	set concurrency(value: number);
	get concurrency(): number;
}
export type Headers = {
	[key: string]: string | string[] | undefined;
};
export type ErrorRequestInfo = {
	method?: string;
	url: string;
	query?: string;
	data?: NodeFormData | FormData | SupportedFileInput;
	headers?: Headers;
};
export type ErrorResponseInfo = {
	error?: {
		statusCode: number;
		content: string;
		errorCode: string;
	};
};
export declare class UploadClientError extends Error {
	isCancel?: boolean;
	readonly code?: string;
	readonly request?: ErrorRequestInfo;
	readonly response?: ErrorResponseInfo;
	readonly headers?: Headers;
	constructor(message: string, code?: string, request?: ErrorRequestInfo, response?: ErrorResponseInfo, headers?: Headers);
}

export {};
